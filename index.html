<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Den of Shadow ðŸ’€ V15.11 FINAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Nosifer&display=swap');
        * { touch-action: none; user-select: none; box-sizing: border-box; outline: none; }
        body { margin: 0; background: #000; color: white; font-family: 'Orbitron', sans-serif; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }

        /* UI Screens (Estilo V11) */
        .ui-screen { position: absolute; inset: 0; background: rgba(0,0,0,0.85); z-index: 5000; display: flex; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(15px); }
        .glass-panel { background: rgba(20,0,0,0.6); border: 1px solid #f00; padding: 30px; border-radius: 15px; width: 90%; max-width: 450px; text-align: center; box-shadow: 0 0 20px rgba(255,0,0,0.2); }
        
        .btn-main { padding: 12px; font-size: 13px; background: rgba(255,0,0,0.1); border: 1px solid #800; color: #fff; cursor: pointer; font-family: 'Orbitron'; margin: 5px 0; width: 100%; transition: 0.3s; text-transform: uppercase; }
        .btn-main:hover { background: #f00; color: #000; box-shadow: 0 0 20px #f00; }

        /* HUD Restaurado V11 */
        #hud { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; display: none; width: 95%; max-width: 600px; pointer-events: none; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #500; border-radius: 10px; }
        .bar-bg { width: 100%; height: 8px; background: #222; margin-top: 4px; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; width: 100%; background: #f00; transition: width 0.3s; }

        /* Minimap circular V11 */
        #minimap-container { position: absolute; top: 20px; right: 20px; width: 130px; height: 130px; border: 2px solid #f00; border-radius: 50%; background: rgba(0,0,0,0.7); overflow: hidden; z-index: 1000; display: none; }
        #minimap { width: 100%; height: 100%; }

        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; z-index: 1500; display: none; pointer-events: none; }
        #crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 4px; height: 4px; background: #f00; border-radius: 50%; }

        /* Mobile Controls */
        #mobile-controls { position: absolute; inset: 0; z-index: 2000; display: none; pointer-events: none; }
        .joy-zone { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.05); border: 1px solid #fff; border-radius: 50%; pointer-events: auto; }
        #stick { position: absolute; top: 35px; left: 35px; width: 50px; height: 50px; background: #fff; border-radius: 50%; opacity: 0.4; }
        .btn-act { position: absolute; bottom: 50px; right: 40px; width: 80px; height: 80px; background: rgba(255,0,0,0.2); border: 2px solid #f00; border-radius: 50%; pointer-events: auto; display: flex; align-items: center; justify-content: center; font-size: 30px; }
    </style>
</head>
<body>

<div id="start-screen" class="ui-screen">
    <div class="glass-panel">
        <h1 style="font-family:'Nosifer'; color:#f00; font-size: 2.2rem;">DEN OF SHADOW</h1>
        <p style="color:#888; font-size: 10px; margin-bottom: 20px;">V15.11 OVERHAUL</p>
        <button class="btn-main" onclick="startGame()">INICIAR RITUAL</button>
        <button class="btn-main" onclick="alert('Discord: killzone1561')">SUPORTE</button>
    </div>
</div>

<div id="pause-screen" class="ui-screen" style="display:none;">
    <div class="glass-panel">
        <h2 style="font-family:'Nosifer'; color:#f00;">PAUSADO</h2>
        <button class="btn-main" onclick="togglePause()">CONTINUAR</button>
        <button class="btn-main" onclick="location.reload()">REINICIAR JOGO</button>
    </div>
</div>

<div id="hud">
    <div class="stats-grid">
        <div>
            <div style="font-size:9px; color:#888;">VITALIDADE</div>
            <div class="bar-bg"><div id="hp-fill" class="bar-fill"></div></div>
        </div>
        <div style="text-align:center;">
            <div id="biome-name" style="font-size:9px; color:#f00;">LABIRINTO</div>
            <div id="room-txt" style="font-size:18px; font-weight:bold;">1</div>
        </div>
        <div style="text-align:right;">
            <div style="font-size:9px; color:#888;" id="ammo-click">MUNIÃ‡ÃƒO</div>
            <div id="soul-hud" style="color:#ff0; font-size:18px; font-weight:bold;">0</div>
        </div>
    </div>
</div>

<div id="minimap-container"><canvas id="minimap"></canvas></div>
<div id="crosshair"></div>

<div id="mobile-controls">
    <div class="joy-zone" id="joy-base"><div id="stick"></div></div>
    <div class="btn-act" id="btn-fire">ðŸ”¥</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const G = { 
    play: false, paused: false, room: 1, hp: 100, maxHp: 100, souls: 0, 
    res: 2, god: false, isMobile: false, wallColor: '#500', isShop: false 
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mCanvas = document.getElementById('minimap');
const mCtx = mCanvas.getContext('2d');

const TILE = 64, MAP_SIZE = 24;
let map = [], enemies = [], bullets = [], shopItems = [], keys = {};
let player = { x: 0, y: 0, angle: 0, pitch: 0, fov: Math.PI / 3 };
let inputBuffer = "";
let cheatCount = 0;

function setupRoom() {
    map = Array(MAP_SIZE * MAP_SIZE).fill(0);
    enemies = []; shopItems = [];
    G.isShop = (G.room % 5 === 0);
    
    document.getElementById('biome-name').innerText = G.isShop ? "MERCADO NEGRO" : "ABISMO";
    document.getElementById('biome-name').style.color = G.isShop ? "#ff0" : "#f00";

    for(let i=0; i<MAP_SIZE; i++){ 
        map[i]=1; map[i+(MAP_SIZE*(MAP_SIZE-1))]=1; 
        map[i*MAP_SIZE]=1; map[i*MAP_SIZE+(MAP_SIZE-1)]=1; 
    }

    if (G.isShop) {
        G.wallColor = '#FFD700';
        spawnShop(10, 10, 'VIDA', 0);
        spawnShop(14, 10, 'MUNIÃ‡ÃƒO', 0);
    } else {
        G.wallColor = `hsl(${(G.room * 45) % 360}, 70%, 25%)`;
        for(let i=0; i<12; i++) {
            let rx = 5+Math.floor(Math.random()*14), ry = 5+Math.floor(Math.random()*14);
            map[ry*MAP_SIZE+rx] = 1;
        }
        for(let i=0; i<3 + Math.floor(G.room/2); i++) {
            enemies.push({x: (8+Math.random()*8)*TILE, y: (8+Math.random()*8)*TILE, hp: 60, alive: true, speed: 1.5});
        }
    }
    // Porta de SaÃ­da Centralizada no Topo
    map[Math.floor(MAP_SIZE/2)] = 2; 
    player.x = 12*TILE; player.y = 21*TILE; player.angle = -Math.PI/2;
}

function spawnShop(tx, ty, name, price) {
    shopItems.push({ x: tx*TILE, y: ty*TILE, name, price, active: true, offset: 0 });
}

function setupInputs() {
    window.onkeydown = e => {
        const k = e.key.toLowerCase(); keys[k] = true;
        if(e.key === "Escape") togglePause();
        inputBuffer += k;
        if(inputBuffer.includes("kadtr")) { G.god = true; G.hp = 999; inputBuffer=""; alert("GOD MODE!"); }
    };
    window.onkeyup = e => delete keys[e.key.toLowerCase()];

    // Cheat Mobile na muniÃ§Ã£o
    document.getElementById('ammo-click').style.pointerEvents = "auto";
    document.getElementById('ammo-click').onclick = () => {
        cheatCount++;
        if(cheatCount >= 5) { G.god = true; G.hp = 999; alert("MODO KADTR ATIVADO!"); }
    };

    canvas.addEventListener('mousedown', e => {
        if(!G.play || G.paused) return;
        if(!document.pointerLockElement && !G.isMobile) canvas.requestPointerLock();
        else if(e.button === 0) shoot();
    });

    document.addEventListener('pointerlockchange', () => {
        if (!document.pointerLockElement && G.play && !G.paused && !G.isMobile) togglePause();
    });

    window.addEventListener('mousemove', e => {
        if(document.pointerLockElement && !G.paused) {
            player.angle += e.movementX * 0.0025;
            player.pitch = Math.max(-400, Math.min(400, player.pitch - e.movementY * 1.5));
        }
    });

    // Joystick Mobile
    if(G.isMobile) {
        const base = document.getElementById('joy-base');
        const stick = document.getElementById('stick');
        base.addEventListener('touchmove', e => {
            const t = e.touches[0]; const r = base.getBoundingClientRect();
            window.mX = (t.clientX - (r.left+60))/50; window.mY = (t.clientY - (r.top+60))/50;
            stick.style.transform = `translate(${Math.max(-30, Math.min(30, window.mX*30))}px, ${Math.max(-30, Math.min(30, window.mY*30))}px)`;
        });
        base.addEventListener('touchend', () => { window.mX=0; window.mY=0; stick.style.transform='none'; });
        document.getElementById('btn-fire').addEventListener('touchstart', shoot);
    }
}

function shoot() {
    bullets.push({x: player.x, y: player.y, vx: Math.cos(player.angle)*22, vy: Math.sin(player.angle)*22, life: 60});
}

function togglePause() {
    G.paused = !G.paused;
    document.getElementById('pause-screen').style.display = G.paused ? 'flex' : 'none';
    if(!G.paused && !G.isMobile) canvas.requestPointerLock();
}

function startGame() {
    G.isMobile = /Android|iPhone/i.test(navigator.userAgent);
    document.getElementById('start-screen').style.display = 'none';
    document.querySelectorAll('#hud, #minimap-container, #crosshair').forEach(el => el.style.display = 'block');
    if(G.isMobile) document.getElementById('mobile-controls').style.display = 'block';
    setupInputs(); setupRoom(); G.play = true; loop();
}

function update() {
    if(!G.play || G.paused) return;
    if(G.god) G.hp = 999;

    let mx = 0, my = 0;
    if(keys['w']) { mx += Math.cos(player.angle); my += Math.sin(player.angle); }
    if(keys['s']) { mx -= Math.cos(player.angle); my -= Math.sin(player.angle); }
    if(keys['a']) { mx += Math.cos(player.angle - Math.PI/2); my += Math.sin(player.angle - Math.PI/2); }
    if(keys['d']) { mx += Math.cos(player.angle + Math.PI/2); my += Math.sin(player.angle + Math.PI/2); }
    
    if(G.isMobile) {
        mx += (window.mY || 0) * -Math.cos(player.angle) + (window.mX || 0) * Math.cos(player.angle+Math.PI/2);
        my += (window.mY || 0) * -Math.sin(player.angle) + (window.mX || 0) * Math.sin(player.angle+Math.PI/2);
    }

    let nx = player.x + mx * 5, ny = player.y + my * 5;
    let gridX = Math.floor(nx/TILE), gridY = Math.floor(ny/TILE);
    
    if(map[gridY*MAP_SIZE + gridX] !== 1) {
        player.x = nx; player.y = ny;
    }

    // LÃ³gica da Porta (AvanÃ§ar de sala)
    if(map[gridY*MAP_SIZE + gridX] === 2) {
        const enemiesAlive = enemies.some(en => en.alive);
        if(!enemiesAlive) {
            G.room++;
            setupRoom();
        }
    }

    // Inimigos e Balas
    bullets.forEach((b, i) => {
        b.x += b.vx; b.y += b.vy; b.life--;
        enemies.forEach(en => {
            if(en.alive && Math.hypot(b.x-en.x, b.y-en.y) < 35) { 
                en.hp -= 40; bullets.splice(i,1); 
                if(en.hp<=0){ en.alive=false; G.souls += 1; }
            }
        });
        if(b.life < 0 || map[Math.floor(b.y/TILE)*MAP_SIZE + Math.floor(b.x/TILE)] === 1) bullets.splice(i,1);
    });

    enemies.forEach(en => {
        if(!en.alive) return;
        let d = Math.hypot(player.x-en.x, player.y-en.y);
        if(d < 500) { en.x += (player.x-en.x)/d * en.speed; en.y += (player.y-en.y)/d * en.speed; }
        if(d < 45) { G.hp -= 0.5; if(G.hp <= 0 && !G.god) location.reload(); }
    });

    shopItems.forEach(s => {
        s.offset = Math.sin(Date.now()*0.005)*10;
        if(s.active && Math.hypot(player.x-s.x, player.y-s.y) < 60) { s.active = false; G.hp = G.maxHp; }
    });

    document.getElementById('hp-fill').style.width = (G.hp/G.maxHp*100) + "%";
    document.getElementById('soul-hud').innerText = G.souls;
    document.getElementById('room-txt').innerText = G.room;
}

function draw() {
    ctx.fillStyle = "#050000"; ctx.fillRect(0,0,canvas.width, canvas.height/2 + player.pitch);
    ctx.fillStyle = "#100505"; ctx.fillRect(0,canvas.height/2 + player.pitch, canvas.width, canvas.height);

    for(let i=0; i<canvas.width; i+=G.res) {
        let ang = (player.angle - player.fov/2) + (i/canvas.width)*player.fov;
        let d=0, hit=0, cos=Math.cos(ang), sin=Math.sin(ang);
        while(hit === 0 && d < 900) {
            d += 7;
            let tx = Math.floor((player.x + cos*d)/TILE), ty = Math.floor((player.y + sin*d)/TILE);
            if(map[ty*MAP_SIZE+tx] > 0) {
                hit = map[ty*MAP_SIZE+tx];
                let h = (TILE * canvas.height) / (d * Math.cos(player.angle-ang));
                ctx.fillStyle = hit === 2 ? '#0f0' : G.wallColor;
                ctx.fillRect(i, (canvas.height-h)/2 + player.pitch, G.res, h);
            }
        }
    }

    [...enemies, ...shopItems].forEach(s => {
        if(s.alive === false || s.active === false) return;
        let ang = Math.atan2(s.y-player.y, s.x-player.x) - player.angle;
        while(ang < -Math.PI) ang += Math.PI*2; while(ang > Math.PI) ang -= Math.PI*2;
        if(Math.abs(ang) < player.fov) {
            let d = Math.hypot(player.x-s.x, player.y-s.y);
            let sx = (0.5 * (ang/(player.fov/2)) + 0.5) * canvas.width;
            let sh = (TILE * canvas.height) / d;
            ctx.fillStyle = s.price !== undefined ? "#ff0" : "#000";
            ctx.fillRect(sx-sh/4, (canvas.height-sh/2)/2+player.pitch + (s.offset || 0), sh/2, sh/2);
        }
    });
    drawMinimap();
}

function drawMinimap() {
    mCtx.fillStyle = "#000"; mCtx.fillRect(0,0,130,130);
    const s = 130/MAP_SIZE;
    for(let y=0; y<MAP_SIZE; y++) for(let x=0; x<MAP_SIZE; x++) {
        if(map[y*MAP_SIZE+x] === 1) { mCtx.fillStyle = G.wallColor; mCtx.fillRect(x*s, y*s, s, s); }
        if(map[y*MAP_SIZE+x] === 2) { mCtx.fillStyle = "#0f0"; mCtx.fillRect(x*s, y*s, s, s); }
    }
    mCtx.fillStyle = "#fff"; mCtx.fillRect((player.x/TILE)*s-1, (player.y/TILE)*s-1, 3, 3);
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; mCanvas.width=130; mCanvas.height=130; };
window.onresize();
</script>
</body>
</html>
