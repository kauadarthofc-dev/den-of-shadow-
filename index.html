<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Den of Shadow ðŸ’€ V2.5</title>
    <link rel="icon" href="https://public-frontend-cos.metadl.com/mgx/img/favicon_atoms.ico" type="image/x-icon">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Nosifer&display=swap');
        
        * {
            touch-action: none;
            user-select: none;
            box-sizing: border-box;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            cursor: crosshair;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        /* UI Screens */
        .ui-screen {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
        }
        
        .ui-screen.hidden {
            display: none;
        }
        
        .glass-panel {
            background: linear-gradient(135deg, rgba(30, 0, 0, 0.95) 0%, rgba(10, 0, 0, 0.98) 100%);
            border: 2px solid #f00;
            padding: 25px;
            width: 95%;
            max-width: 500px;
            border-radius: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .game-title {
            font-family: 'Nosifer', cursive;
            color: #f00;
            margin: 0;
            font-size: clamp(24px, 6vw, 36px);
            text-shadow: 0 0 10px #f00, 0 0 20px #f00;
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 10px #f00, 0 0 20px #f00; }
            50% { text-shadow: 0 0 20px #f00, 0 0 40px #f00; }
        }
        
        .version-text {
            font-size: 10px;
            color: #f66;
            margin: 5px 0 20px;
        }
        
        .section-title {
            font-size: 14px;
            color: #fff;
            margin: 0 0 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 0, 0, 0.3);
        }
        
        .menu-section {
            display: none;
            width: 100%;
        }
        
        .menu-section.active {
            display: block;
        }
        
        .save-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .save-slot-container {
            position: relative;
        }
        
        .btn-save {
            width: 100%;
            padding: 15px 10px;
            background: linear-gradient(180deg, #2a0000 0%, #1a0000 100%);
            border: 2px solid #600;
            border-radius: 12px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            font-family: 'Orbitron', sans-serif;
        }
        
        .btn-save:hover {
            background: linear-gradient(180deg, #400000 0%, #2a0000 100%);
            border-color: #f00;
            transform: scale(1.05);
        }
        
        .slot-number {
            font-size: 24px;
            font-weight: bold;
            color: #f00;
        }
        
        .slot-info {
            font-size: 10px;
            color: #888;
        }
        
        .btn-delete {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 28px;
            height: 28px;
            background: #f00;
            color: #000;
            border: none;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            z-index: 10;
        }
        
        .btn-settings, .btn-back {
            width: 100%;
            padding: 12px;
            background: transparent;
            border: 1px solid #444;
            border-radius: 8px;
            color: #888;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }
        
        .btn-settings:hover, .btn-back:hover {
            border-color: #f00;
            color: #fff;
        }
        
        .class-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .btn-class {
            padding: 15px;
            background: linear-gradient(180deg, #1a0505 0%, #0a0000 100%);
            border: 2px solid #400;
            border-radius: 12px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-family: 'Orbitron', sans-serif;
        }
        
        .btn-class:hover {
            transform: scale(1.02);
            border-color: #f00;
        }
        
        .class-icon { font-size: 32px; margin-bottom: 5px; }
        .class-name { font-size: 16px; font-weight: bold; color: #f00; margin-bottom: 8px; }
        .class-stats { display: flex; flex-direction: column; gap: 3px; font-size: 10px; color: #888; margin-bottom: 8px; }
        .class-weapon { font-size: 11px; color: #f66; padding-top: 8px; border-top: 1px solid #300; }
        
        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            pointer-events: none;
            display: none;
            padding: 15px;
        }
        
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .masks-container {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .mask {
            width: 24px;
            height: 30px;
            background: linear-gradient(180deg, #f00 0%, #900 100%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }
        
        .mask.broken {
            background: #333;
            opacity: 0.3;
        }
        
        .stats-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #400;
        }
        
        .stat-item {
            font-size: 12px;
            color: #f00;
        }
        
        .btn-pause {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #f00;
            border-radius: 12px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .enemy-counter {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 20px;
            border-radius: 20px;
            border: 1px solid #f00;
            font-size: 12px;
            color: #f00;
        }
        
        #damage-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 50;
        }
        
        #damage-overlay.active {
            opacity: 1;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            position: fixed;
    };
let lTouch = { id: null, x: 0, y: 0 };

// ============================================
// MENU FUNCTIONS
// ============================================

function updateSaveUI() {
    for (let i = 1; i <= 3; i++) {
        const data = localStorage.getItem('den_save_' + i);
        const info = document.getElementById('s' + i + '-info');
        if (info) {
            if (data) {
                const parsed = JSON.parse(data);
                info.innerText = 'Sala: ' + parsed.room;
                info.style.color = '#0f0';
            } else {
                info.innerText = 'Vazio';
                info.style.color = '#888';
            }
        }
    }
}

function deleteSave(slot, event) {
    event.stopPropagation();
    if (confirm('Apagar Slot ' + slot + '?')) {
        localStorage.removeItem('den_save_' + slot);
        updateSaveUI();
    }
}

function selectSlot(slot) {
    G.currentSlot = slot;
    const data = localStorage.getItem('den_save_' + slot);
    
    if (data) {
        const d = JSON.parse(data);
        G.room = d.room;
        G.souls = d.souls;
        G.weapon = d.weapon;
        G.class = d.class;
        applyClassStats(d.class);
        initGame();
    } else {
        document.getElementById('save-menu').classList.remove('active');
        document.getElementById('class-menu').classList.add('active');
    }
}

function showSaveMenu() {
    document.getElementById('class-menu').classList.remove('active');
    document.getElementById('settings-menu').classList.remove('active');
    document.getElementById('save-menu').classList.add('active');
}

function toggleSettings() {
    const settings = document.getElementById('settings-menu');
    const save = document.getElementById('save-menu');
    
    if (settings.classList.contains('active')) {
        settings.classList.remove('active');
        save.classList.add('active');
    } else {
        save.classList.remove('active');
        settings.classList.add('active');
    }
}

function updateSensitivity(value) {
    G.sensitivity = parseInt(value);
    document.getElementById('sens-value').innerText = value;
}

function toggleAutoFire() {
    G.autoFire = !G.autoFire;
    const btn = document.getElementById('autofire-btn');
    btn.innerText = G.autoFire ? 'LIGADO' : 'DESLIGADO';
    btn.classList.toggle('active', G.autoFire);
}

function applyClassStats(type) {
    if (type === 'assassin') {
        G.weapon = 'knife';
        G.speed = 5.5;
        G.hp = G.maxHp = 4;
    } else if (type === 'soldier') {
        G.weapon = 'pistol';
        G.speed = 4;
        G.hp = G.maxHp = 6;
    } else if (type === 'mage') {
        G.weapon = 'magic';
        G.speed = 3.5;
        G.hp = G.maxHp = 5;
    }
}

function startWithClass(type) {
    G.class = type;
    applyClassStats(type);
    initGame();
}

function togglePause() {
    G.paused = !G.paused;
    document.getElementById('pause-menu').classList.toggle('active', G.paused);
}

// ============================================
// GAME INITIALIZATION
// ============================================

function initGame() {
    G.isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || 
                 ('ontouchstart' in window);
    
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('cross').style.display = 'block';
    
    if (G.isMobile) {
        document.getElementById('mobile-controls').style.display = 'block';
        G.res = 6;
    }
    
    setupRoom();
    G.play = true;
    requestAnimationFrame(gameLoop);
}

function setupRoom() {
    saveGame();
    document.getElementById('val-room').innerText = G.room;
    document.getElementById('val-souls').innerText = G.souls;
    updateMasks();
    
    // Create empty map
    map = [];
    for (let i = 0; i < MAP_SIZE * MAP_SIZE; i++) {
        map[i] = 0;
    }
    
    // Create border walls
    for (let i = 0; i < MAP_SIZE; i++) {
        map[i] = 1; // Top
        map[(MAP_SIZE - 1) * MAP_SIZE + i] = 1; // Bottom
        map[i * MAP_SIZE] = 1; // Left
        map[i * MAP_SIZE + MAP_SIZE - 1] = 1; // Right
    }
    
    // Add random walls
    for (let i = 0; i < 12; i++) {
        let wx = 2 + Math.floor(Math.random() * (MAP_SIZE - 4));
        let wy = 2 + Math.floor(Math.random() * (MAP_SIZE - 4));
        // Don't block spawn or door
        if (wx !== 10 && !(wy === MAP_SIZE - 2 && wx > 8 && wx < 12)) {
            map[wy * MAP_SIZE + wx] = 1;
        }
    }
    
    // Door at top center
    G.doorPos = { x: 10 * TILE + TILE / 2, y: TILE + TILE / 2 };
    map[1 * MAP_SIZE + 10] = 2;
    
    // Spawn enemies
    enemies = [];
    let count = Math.min(10, 2 + Math.floor(G.room / 2));
    for (let i = 0; i < count; i++) {
        let ex, ey, attempts = 0;
        do {
            ex = (2 + Math.random() * (MAP_SIZE - 4)) * TILE;
            ey = (2 + Math.random() * (MAP_SIZE - 6)) * TILE;
            attempts++;
        } while (map[Math.floor(ey / TILE) * MAP_SIZE + Math.floor(ex / TILE)] !== 0 && attempts < 50);
        
        enemies.push({
            x: ex,
            y: ey,
            hp: 40 + G.room * 5,
            maxHp: 40 + G.room * 5,
            alive: true,
            type: (G.room % 5 === 0 && i === 0) ? 'BOSS' : 'MOB',
            speed: 1.2 + Math.random() * 0.5
        });
    }
    
    bullets = [];
    updateEnemyCounter();
    
    // Player spawn at bottom center, facing up
    player.x = 10 * TILE + TILE / 2;
    player.y = (MAP_SIZE - 2) * TILE + TILE / 2;
    player.angle = -Math.PI / 2; // Facing up
    player.pitch = 0;
    G.z = 0;
    G.jv = 0;
}

function updateEnemyCounter() {
    document.getElementById('enemy-count').innerText = enemies.filter(e => e.alive).length;
}

function updateMasks() {
    const container = document.getElementById('masks');
    container.innerHTML = '';
    for (let i = 0; i < G.maxHp; i++) {
        const mask = document.createElement('div');
        mask.className = i < G.hp ? 'mask' : 'mask broken';
        container.appendChild(mask);
    }
}

function saveGame() {
    localStorage.setItem('den_save_' + G.currentSlot, JSON.stringify({
        room: G.room,
        souls: G.souls,
        weapon: G.weapon,
        class: G.class
    }));
}

// ============================================
// RENDERING
// ============================================

function draw() {
    const w = canvas.width;
    const h = canvas.height;
    const horizon = h / 2 + player.pitch;
    
    // Sky
    ctx.fillStyle = '#080005';
    ctx.fillRect(0, 0, w, horizon);
    
    // Floor
    ctx.fillSx.arc(mx + (player.x / TILE) * cell, my + (player.y / TILE) * cell, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Direction
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(mx + (player.x / TILE) * cell, my + (player.y / TILE) * cell);
    ctx.lineTo(
        mx + (player.x / TILE) * cell + Math.cos(player.angle) * 8,
        my + (player.y / TILE) * cell + Math.sin(player.angle) * 8
    );
    ctx.stroke();
}

// ============================================
// UPDATE
// ============================================

function update() {
    if (!G.play || G.paused) return;
    
    // Recoil
    if (G.recoil > 0) G.recoil -= 1;
    
    // Jump
    G.z += G.jv;
    G.jv -= 0.8;
    if (G.z <= 0) { G.z = 0; G.jv = 0; }
    
    // Movement
    let mx = 0, my = 0;
    
    if (keys['w'] || keys['arrowup']) { mx += Math.cos(player.angle); my += Math.sin(player.angle); }
    if (keys['s'] || keys['arrowdown']) { mx -= Math.cos(player.angle); my -= Math.sin(player.angle); }
    if (keys['a'] || keys['arrowleft']) { mx += Math.cos(player.angle - Math.PI/2); my += Math.sin(player.angle - Math.PI/2); }
    if (keys['d'] || keys['arrowright']) { mx += Math.cos(player.angle + Math.PI/2); my += Math.sin(player.angle + Math.PI/2); }
    
    if (mJoy.active) {
        mx += Math.cos(player.angle) * (-mJoy.dy) + Math.cos(player.angle + Math.PI/2) * mJoy.dx;
        my += Math.sin(player.angle) * (-mJoy.dy) + Math.sin(player.angle + Math.PI/2) * mJoy.dx;
    }
    
    // Normalize
    const len = Math.sqrt(mx * mx + my * my);
    if (len > 0) { mx /= len; my /= len; }
    
    // Apply movement
    const nx = player.x + mx * G.speed;
    const ny = player.y + my * G.speed;
    
    const txN = Math.floor(nx / TILE);
    const tyN = Math.floor(player.y / TILE);
    if (txN >= 0 && txN < MAP_SIZE && map[tyN * MAP_SIZE + txN] === 0) player.x = nx;
    
    const txY = Math.floor(player.x / TILE);
    const tyY = Math.floor(ny / TILE);
    if (tyY >= 0 && tyY < MAP_SIZE && map[tyY * MAP_SIZE + txY] === 0) player.y = ny;
    
    // Auto-fire
    if (G.autoFire && G.isMobile && G.recoil <= 0) {
        const near = enemies.find(e => e.alive && Math.hypot(player.x - e.x, player.y - e.y) < 350);
        if (near) shoot();
    }
    
    // Enemies
    enemies.forEach(en => {
        if (!en.alive) return;
        
        const dx = player.x - en.x;
        const dy = player.y - en.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist < 450 && dist > 35) {
            const ang = Math.atan2(dy, dx);
            const ex = en.x + Math.cos(ang) * en.speed;
            const ey = en.y + Math.sin(ang) * en.speed;
            
            const etx = Math.floor(ex / TILE);
            const ety = Math.floor(ey / TILE);
            if (etx >= 0 && etx < MAP_SIZE && ety >= 0 && ety < MAP_SIZE && map[ety * MAP_SIZE + etx] === 0) {
                en.x = ex;
                en.y = ey;
            }
        }
        
        // Damage player
        if (dist < 45 && Date.now() - G.lastHit > 800) {
            G.hp--;
            G.lastHit = Date.now();
            updateMasks();
            document.getElementById('damage-overlay').classList.add('active');
            setTimeout(() => document.getElementById('damage-overlay').classList.remove('active'), 200);
            
            if (G.hp <= 0) {
                alert('VOCÃŠ MORREU!\nSala: ' + G.room + ' | Almas: ' + G.souls);
                location.reload();
            }
        }
    });
    
    // Bullets
    bullets = bullets.filter(b => {
        b.x += b.vx;
        b.y += b.vy;
        b.life--;
        
        // Hit enemies
        for (let en of enemies) {
            if (en.alive && Math.hypot(b.x - en.x, b.y - en.y) < 35) {
                en.hp -= b.magic ? 50 : 30;
                if (en.hp <= 0) {
                    en.alive = false;
                    G.souls += en.type === 'BOSS' ? 50 : 15;
                    document.getElementById('val-souls').innerText = G.souls;
                    updateEnemyCounter();
                }
                return false;
            }
        }
        
        // Hit wall
        const tx = Math.floor(b.x / TILE);
        const ty = Math.floor(b.y / TILE);
        if (tx < 0 || tx >= MAP_SIZE || ty < 0 || ty >= MAP_SIZE || map[ty * MAP_SIZE + tx] !== 0) {
            return false;
        }
        
        return b.life > 0;
    });
}

function shoot() {
    if (G.recoil > 0) return;
    G.recoil = 15;
    
    if (G.weapon === 'knife') {
        enemies.forEach(en => {
            if (!en.alive) return;
            const dx = en.x - player.x;
            const dy = en.y - player.y;
            const dist = Math.hypot(dx, dy);
            const ang = Math.atan2(dy, dx) - player.angle;
            const normAng = ((ang + Math.PI) % (Math.PI * 2)) - Math.PI;
            
            if (dist < 90 && Math.abs(normAng) < Math.PI / 3) {
                en.hp -= 60;
                if (en.hp <= 0) {
                    en.alive = false;
                    G.souls += en.type === 'BOSS' ? 50 : 15;
                    document.getElementById('val-souls').innerText = G.souls;
                    updateEnemyCounter();
                }
            }
        });
    } else {
        bullets.push({
            x: player.x,
            y: player.y,
            vx: Math.cos(player.angle) * 16,
            vy: Math.sin(player.angle) * 16,
            life: 70,
            magic: G.weapon === 'magic'
        });
    }
}

function performInteract() {
    const dist = Math.hypot(player.x - G.doorPos.x, player.y - G.doorPos.y);
    if (enemies.every(e => !e.alive) && dist < 100) {
        G.room++;
        setupRoom();
    }
}

// ============================================
// CONTROLS
// ============================================

// Keyboard
window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'e') performInteract();
    if (e.code === 'Space' && G.z === 0) G.jv = 12;
    if (e.key === 'Escape') togglePause();
});

window.addEventListener('keyup', e => {
    delete keys[e.key.toLowerCase()];
});

// Mouse
window.addEventListener('mousedown', () => {
    if (G.play && !G.paused) {
        if (document.pointerLockElement === canvas) {
            shoot();
        } else {
            canvas.requestPointerLock();
        }
    }
});

window.addEventListener('mousemove', e => {
    if (document.pointerLockElement === canvas && G.play && !G.paused) {
        const sens = G.sensitivity / 5;
        player.angle += e.movementX * 0.003 * sens;
        player.pitch = Math.max(-80, Math.min(80, player.pitch - e.movementY * 0.4 * sens));
    }
});

// Mobile Joystick
const moveZone = document.getElementById('move-zone');
const stick = document.getElementById('stick');

moveZone.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    const rect = moveZone.getBoundingClientRect();
    mJoy.active = true;
    mJoy.id = t.identifier;
    mJoy.sx = rect.left + rect.width / 2;
    mJoy.sy = rect.top + rect.height / 2;
}, { passive: false });

moveZone.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const t of e.changedTouches) {
        if (t.identifier === mJoy.id) {
            const dx = t.clientX - mJoy.sx;
            const dy = t.clientY - mJoy.sy;
            const dist = Math.min(50, Math.hypot(dx, dy));
            const ang = Math.atan2(dy, dx);
            mJoy.dx = Math.cos(ang) * dist / 50;
            mJoy.dy = Math.sin(ang) * dist / 50;
            stick.style.transform = 'translate(calc(-50% + ' + (Math.cos(ang) * dist) + 'px), calc(-50% + ' + (Math.sin(ang) * dist) + 'px))';
        }
    }
}, { passive: false });

moveZone.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
        if (t.identifier === mJoy.id) {
            mJoy.active = false;
            mJoy.dx = 0;
            mJoy.dy = 0;
            stick.style.transform = 'translate(-50%, -50%)';
        }
    }
});

// Look Zone
const lookZone = document.getElementById('look-zone');

lookZone.addEventListener('touchstart', e => {
    const t = e.changedTouches[0];
    lTouch.id = t.identifier;
    lTouch.x = t.clientX;
    lTouch.y = t.clientY;
}, { passive: true });

lookZone.addEventListener('touchmove', e => {
    for (const t of e.changedTouches) {
        if (t.identifier === lTouch.id) {
            const sens = G.sensitivity / 5;
            player.angle += (t.clientX - lTouch.x) * 0.005 * sens;
            player.pitch = Math.max(-80, Math.min(80, player.pitch - (t.clientY - lTouch.y) * 0.6 * sens));
            lTouch.x = t.clientX;
            lTouch.y = t.clientY;
        }
    }
}, { passive: true });

lookZone.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
        if (t.identifier === lTouch.id) {
            lTouch.id = null;
        }
    }
});

// Action Buttons
document.getElementById('btn-fire').addEventListener('touchstart', e => {
    e.preventDefault();
    shoot();
}, { passive: false });

document.getElementById('btn-interact').addEventListener('touchstart', e => {
    e.preventDefault();
    performInteract();
}, { passive: false });

document.getElementById('btn-jump').addEventListener('touchstart', e => {
    e.preventDefault();
    if (G.z === 0) G.jv = 12;
}, { passive: false });

// ============================================
// GAME LOOP
// ============================================

function gameLoop() {
    update();
    draw();
    i
