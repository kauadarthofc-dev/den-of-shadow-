<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Den of Shadow üíÄ Lord of Light</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Nosifer&family=Special+Elite&display=swap');
        
        * { touch-action: none; user-select: none; box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; color: white; font-family: 'Orbitron', sans-serif; overflow: hidden; position: fixed; width: 100%; height: 100%; }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* HUD ESTILO ISAAC */
        #hud-container { position: absolute; inset: 0; pointer-events: none; z-index: 1000; display: none; padding: 15px; }
        
        .hud-left { position: absolute; top: 15px; left: 15px; display: flex; flex-direction: column; gap: 5px; }
        .hud-right { position: absolute; top: 15px; right: 15px; text-align: right; }
        
        .stat-row { display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.4); padding: 4px 10px; border-radius: 5px; }
        .bar-outer { width: 120px; height: 10px; background: #222; border: 1px solid #444; overflow: hidden; }
        .bar-inner { height: 100%; transition: width 0.3s; }

        /* MINIMAPA */
        #minimap-canvas { 
            width: 120px; height: 80px; 
            background: rgba(255, 0, 0, 0.05); 
            border: 2px solid rgba(255, 0, 0, 0.3);
            margin-bottom: 5px;
        }

        /* CONTROLES MOBILE VISUAIS */
        .touch-zone { position: absolute; bottom: 0; width: 50%; height: 50%; pointer-events: auto; z-index: 2000; }
        #left-zone { left: 0; }
        #right-zone { right: 0; }
        
        /* Joystick Virtual */
        .joystick-base {
            position: absolute; width: 100px; height: 100px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; display: none; pointer-events: none;
            background: rgba(0,0,0,0.2);
            transform: translate(-50%, -50%);
        }
        .joystick-stick {
            position: absolute; width: 40px; height: 40px;
            background: rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255,0,0,0.5);
        }

        /* Bot√£o Trocar Arma (Mobile) */
        #mobile-swap-btn {
            position: absolute; bottom: 180px; right: 30px;
            width: 60px; height: 60px;
            background: rgba(0,0,0,0.6);
            border: 2px solid #ff4500; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 2100;
            font-size: 30px; color: #ff4500;
            display: none; /* S√≥ aparece via JS se touch */
        }
        #mobile-swap-btn:active { background: #ff4500; color: #000; }

        /* UI TELAS */
        .ui-screen { 
            position: absolute; inset: 0; 
            background: radial-gradient(circle at center, #4a0404 0%, #000000 100%);
            z-index: 3000; display: flex; flex-direction: column; align-items: center; justify-content: center; 
        }
        #start-screen h1 { font-family: 'Nosifer', cursive; font-size: clamp(30px, 8vw, 60px); color: #ff0000; text-shadow: 0 0 20px #ff0000; margin: 10px; text-align: center; }
        .btn-main { padding: 15px 40px; font-size: 18px; background: transparent; border: 2px solid #ff0000; color: #fff; cursor: pointer; font-family: 'Orbitron'; margin: 10px; transition: 0.3s; z-index: 3100; }
        .social-links a { color: #ff0000; text-decoration: none; font-size: 12px; display: block; margin: 5px; }
        #cutscene-screen { background: #000; text-align: center; padding: 20px; display: none; }
        #msg-popup { position: absolute; top: 25%; width: 100%; text-align: center; font-size: 24px; color: #ff0000; display: none; z-index: 2000; font-family: 'Nosifer'; pointer-events: none; text-shadow: 0 0 10px #000; }

        /* TELA DE UPGRADE */
        #upgrade-screen {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            z-index: 4000; display: none; flex-direction: column; 
            align-items: center; justify-content: center;
        }
        .cards-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; padding: 20px; }
        .upg-card {
            width: 200px; height: 300px; background: #111;
            border: 2px solid #444; border-radius: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            padding: 15px; cursor: pointer; text-align: center; transition: 0.2s;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            position: relative; overflow: hidden;
        }
        .upg-card:hover { transform: scale(1.05); }
        .upg-rarity { font-size: 12px; text-transform: uppercase; margin-bottom: 5px; font-weight: bold; }
        .upg-name { font-size: 16px; font-weight: bold; margin-bottom: 10px; color: #fff; }
        .upg-desc { font-size: 12px; color: #ccc; }
        
        /* Cores de Raridade */
        .common { border-color: #999; box-shadow: 0 0 10px #999; } .common .upg-rarity { color: #999; }
        .rare { border-color: #00aaff; box-shadow: 0 0 10px #00aaff; } .rare .upg-rarity { color: #00aaff; }
        .epic { border-color: #a0f; box-shadow: 0 0 10px #a0f; } .epic .upg-rarity { color: #a0f; }
        .legendary { border-color: #ffd700; box-shadow: 0 0 20px #ffd700; animation: glow 2s infinite alternate; } .legendary .upg-rarity { color: #ffd700; }

        @keyframes glow { from { box-shadow: 0 0 20px #ffd700; } to { box-shadow: 0 0 40px #ff4500; } }

    </style>
</head>
<body>

<div id="hud-container">
    <div class="hud-left">
        <div class="stat-row">
            <span style="color:#ff0000; font-size:12px;">HP</span>
            <div class="bar-outer"><div id="hp-bar" class="bar-inner" style="background:#ff0000; width:100%;"></div></div>
        </div>
        <div class="stat-row">
            <span style="color:#f1c40f; font-size:12px;">AM</span>
            <div class="bar-outer"><div id="ammo-bar" class="bar-inner" style="background:#f1c40f; width:100%;"></div></div>
        </div>
        <div style="font-size: 14px; color: #ff0000; margin-top:5px;">SALA: <span id="room-txt">0</span></div>
        <div style="font-size: 12px; color: #aaa; margin-top:5px;">ARMA: <span id="weapon-txt">LUZ</span></div>
    </div>

    <div class="hud-right">
        <canvas id="minimap-canvas"></canvas>
    </div>

    <div id="left-zone" class="touch-zone"></div>
    <div id="right-zone" class="touch-zone"></div>
    
    <div id="joy-left" class="joystick-base"><div class="joystick-stick"></div></div>
    <div id="joy-right" class="joystick-base"><div class="joystick-stick"></div></div>

    <div id="mobile-swap-btn" onclick="swapWeapon()">
        <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
            <path d="M3 3v5h5"></path>
            <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path>
            <path d="M16 21h5v-5"></path>
        </svg>
    </div>
</div>

<div id="start-screen" class="ui-screen">
    <h1>DEN OF SHADOW</h1>
    <p id="subtitle" style="letter-spacing: 5px; color: #ff0000; margin-bottom: 20px;">LORD OF LIGHT</p>
    <button class="btn-main" onclick="initCutscene()">JOGAR</button>
    <div class="social-links">
        <a href="mailto:kauaderthofc@gmail.com">kauaderthofc@gmail.com</a>
        <a href="https://youtube.com/@kaua_darth" target="_blank">YouTube: @kaua_darth</a>
    </div>
</div>

<div id="cutscene-screen" class="ui-screen" onclick="nextHistory()">
    <div id="cutscene-text" style="font-family: 'Special Elite'; font-size: 1.2rem; max-width: 80%; line-height: 1.5;"></div>
    <div style="position: absolute; bottom: 40px; font-size: 10px; opacity: 0.5;">TOQUE PARA CONTINUAR</div>
</div>

<div id="upgrade-screen">
    <h2 style="color: #fff; font-family: 'Nosifer'; margin-bottom: 20px;">ESCOLHA UMA D√ÅDIVA</h2>
    <div class="cards-container" id="upgrade-cards-area"></div>
</div>

<div id="msg-popup"></div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mCanvas = document.getElementById('minimap-canvas');
const mCtx = mCanvas.getContext('2d');

// Gerenciamento de Tamanho da Sala
let ROOM_W = 1600;
let ROOM_H = 1000;
const WALL_SIZE = 70;

// --- BANCO DE DADOS DE UPGRADES (REBALANCEADO) ---
const UPGRADES_DB = [
    // COMUM (60%)
    { id: 'hp1', name: 'Vitalidade Menor', desc: '+20 Max HP', rarity: 'common', apply: p => G.maxHp += 20 },
    { id: 'dmg1', name: 'For√ßa Bruta', desc: '+10% Dano', rarity: 'common', apply: p => p.dmgMult += 0.1 },
    { id: 'spd1', name: 'Botas Leves', desc: '+5% Velocidade', rarity: 'common', apply: p => player.spd *= 1.05 },
    { id: 'ammo1', name: 'Cartucheira', desc: '+10 Muni√ß√£o Max', rarity: 'common', apply: p => { G.maxAmmo += 10; G.ammo += 10; } },
    { id: 'rl1', name: 'M√£os √Ågeis', desc: '-10% Tempo Recarga', rarity: 'common', apply: p => G.reloadTime *= 0.9 },
    { id: 'heal1', name: 'Curativo', desc: 'Recupera 50 HP Agora', rarity: 'common', apply: p => G.hp = Math.min(G.maxHp, G.hp + 50) },
    
    // RARO (30%)
    { id: 'hp2', name: 'Cora√ß√£o de Pedra', desc: '+50 Max HP', rarity: 'rare', apply: p => G.maxHp += 50 },
    { id: 'dmg2', name: 'L√¢mina Sombria', desc: '+25% Dano', rarity: 'rare', apply: p => p.dmgMult += 0.25 },
    { id: 'spd2', name: 'Passo Fantasma', desc: '+15% Velocidade', rarity: 'rare', apply: p => player.spd *= 1.15 },
    { id: 'fr1', name: 'Gatilho R√°pido', desc: '+20% Cad√™ncia', rarity: 'rare', apply: p => p.fireRateMult *= 0.8 },
    { id: 'crt1', name: 'Olho Preciso', desc: '+15% Chance Cr√≠tico', rarity: 'rare', apply: p => p.critChance += 0.15 },
    { id: 'vamp1', name: 'Sede de Sangue', desc: '2% Cura ao matar', rarity: 'rare', apply: p => p.lifesteal += 0.02 },

    // √âPICO (8%)
    { id: 'dmg3', name: 'Poder do Lorde', desc: '+50% Dano', rarity: 'epic', apply: p => p.dmgMult += 0.5 },
    { id: 'pierce', name: 'Balas Perfurantes', desc: 'Tiros atravessam inimigos', rarity: 'epic', apply: p => p.pierce += 2 },
    { id: 'regen', name: 'Regenera√ß√£o', desc: 'Recupera HP lentamente', rarity: 'epic', apply: p => p.regen = true },
    { id: 'explode', name: 'Detona√ß√£o', desc: 'Inimigos explodem ao morrer', rarity: 'epic', apply: p => p.explode = true },
    { id: 'shield', name: 'Escudo Arcano', desc: '-20% Dano Recebido', rarity: 'epic', apply: p => p.dmgRed += 0.2 },
    
    // LEND√ÅRIO (2%)
    { id: 'multi', name: 'Tiro Duplo', desc: 'Dispara +1 proj√©til extra', rarity: 'legendary', apply: p => p.multishot += 1 },
    { id: 'god', name: 'Imortalidade Menor', desc: '+100 HP, Full Heal, +30% Dano', rarity: 'legendary', apply: p => { G.maxHp += 100; p.dmgMult += 0.3; G.hp = G.maxHp; } },
    { id: 'minigun', name: 'Minigun', desc: 'Muni√ß√£o Infinita, Dano -30%', rarity: 'legendary', apply: p => { G.infiniteAmmo = true; p.dmgMult *= 0.7; } },
    { id: 'sniper', name: 'Rifle de Elite', desc: 'Dano x3, Cad√™ncia lenta', rarity: 'legendary', apply: p => { p.dmgMult *= 3; p.fireRateMult *= 1.8; } },
    { id: 'sword_king', name: 'Mestre da Espada', desc: 'Espada do Rei reflete tiros e √© maior', rarity: 'legendary', apply: p => p.swordMaster = true }
];

const G = { 
    play: false, room: 0, hp: 100, maxHp: 100, ammo: 30, maxAmmo: 30, 
    reloading: false, enemiesDefeated: false, 
    lastShot: 0,
    clearedRooms: new Set(),
    savedRooms: {}, // Salva itens deixados na sala
    reloadTime: 1000,
    infiniteAmmo: false,
    // Player Mods
    mods: { dmgMult: 1, sizeMult: 1, projSpdMult: 1, fireRateMult: 1, lifesteal: 0, critChance: 0, pierce: 0, multishot: 0, dmgRed: 0, instakill: false, regen: false, explode: false, swordMaster: false },
    // Weapons
    weapons: [
        { name: "LUZ", type: 'range', dmg: 40, spd: 20, rate: 200, color: "#fff", size: 10 },
        { name: "FOGO", type: 'range', dmg: 90, spd: 25, rate: 400, color: "#ff4500", size: 18 },
        { name: "REI", type: 'melee', dmg: 120, spd: 0, rate: 500, color: "#9932CC", size: 60 }
    ],
    curWpn: 0,
    unlockedWeapons: [0] // √çndices desbloqueados
};

// Controles Touch
let touchMove = { x: 0, y: 0, active: false, startX:0, startY:0 };
let touchShoot = { x: 0, y: 0, active: false, startX:0, startY:0 };

const texts = {
    pt: {
        sub: "LORDE DA LUZ", boss: "GUARDI√ÉO!", weapon: "ARMA NOVA!", sword: "ESPADA DO REI!", upgrade: "PODER OBTIDO!",
        history: [
            "O Lorde da Luz foi tra√≠do por sua pr√≥pria sombra...",
            "Agora ele rasteja no Den of Shadow para recuperar seu poder.",
            "Rumores dizem que a Espada do Rei est√° perdida aqui.",
            "Use o lado esquerdo para andar e o direito para atacar."
        ]
    }
};

let player = { x: 800, y: 800, r: 25, spd: 9, angle: 0 };
let enemies = [], projectiles = [], drops = [], objects = [], visuals = [];
const keys = {};

function initCutscene() {
    document.getElementById('start-screen').style.display='none';
    document.getElementById('cutscene-screen').style.display='flex';
    nextHistory();
    if('ontouchstart' in window) document.getElementById('mobile-swap-btn').style.display = 'flex';
}

let hIdx = 0;
function nextHistory() {
    if (hIdx < texts.pt.history.length) {
        document.getElementById('cutscene-text').innerText = texts.pt.history[hIdx++];
    } else {
        startGame();
    }
}

function startGame() {
    document.getElementById('cutscene-screen').style.display='none';
    document.getElementById('hud-container').style.display='block';
    G.play = true;
    G.clearedRooms.add(0);
    // Adicionar Espada do Rei na lista de desbloqueio para testar ou como drop
    // Vamos deixar como drop na sala 3
    initRoom('bottom');
    setInterval(() => { if(G.mods.regen && G.play && G.hp < G.maxHp) G.hp++; }, 2000);
}

function saveRoomState() {
    // Salva drops e objetos atuais para a sala atual
    G.savedRooms[G.room] = {
        drops: [...drops],
        objects: [...objects]
    };
}

function loadRoomState() {
    if (G.savedRooms[G.room]) {
        drops = [...G.savedRooms[G.room].drops];
        objects = [...G.savedRooms[G.room].objects];
    }
}

function initRoom(entrySide) {
    saveRoomState(); // Salva a sala anterior antes de mudar

    // Redimensionar sala se for Boss
    let isBoss = (G.room > 0 && G.room % 10 === 0);
    if (isBoss) { ROOM_W = 2400; ROOM_H = 1600; } 
    else { ROOM_W = 1600; ROOM_H = 1000; }

    enemies = []; projectiles = []; visuals = [];
    drops = []; objects = []; // Limpa temporariamente, depois carrega

    if (entrySide === 'bottom') {
        player.x = ROOM_W / 2; player.y = ROOM_H - WALL_SIZE - 80;
    } else {
        player.x = ROOM_W / 2; player.y = WALL_SIZE + 80;
    }

    if (G.clearedRooms.has(G.room)) {
        G.enemiesDefeated = true;
        loadRoomState(); // Carrega itens deixados
    } else {
        G.enemiesDefeated = false;
        if (G.room > 0) {
            if (isBoss) {
                // BOSS SPAWN
                enemies.push({ 
                    x: ROOM_W/2, y: 300, 
                    hp: 1500 + (G.room * 200), maxHp: 1500+(G.room*200), 
                    r: 120, spd: 4, isBoss: true, 
                    state: 'idle', timer: 100, phase: 1 
                });
                showPopup(texts.pt.boss);
            } else {
                // INIMIGOS NORMAIS (Menos quantidade, mais IA)
                let count = 3 + Math.floor(G.room * 0.6); 
                for(let i=0; i<count; i++) {
                    enemies.push({ 
                        x: Math.random()*(ROOM_W-300)+150, y: Math.random()*(ROOM_H-500)+150, 
                        hp: 90 + G.room*25, maxHp: 90+G.room*25, r: 35, spd: 2 + Math.random(), 
                        behavior: Math.random() < 0.5 ? 'chase' : 'flank',
                        flankAngle: Math.random() * Math.PI * 2
                    });
                }
            }
        } else { G.enemiesDefeated = true; }
    }
}

function showPopup(t) {
    const p = document.getElementById('msg-popup');
    p.innerText = t; p.style.display = 'block';
    p.style.opacity = 1;
    setTimeout(() => p.style.display = 'none', 2500);
}

// --- LOGICA BOSS & IA ---
function updateBoss(boss) {
    boss.timer--;
    
    // Troca de Estado
    if (boss.timer <= 0) {
        let r = Math.random();
        if (r < 0.4) { boss.state = 'charge'; boss.timer = 120; }
        else if (r < 0.8) { boss.state = 'shoot'; boss.timer = 180; }
        else { boss.state = 'summon'; boss.timer = 100; }
    }

    // Comportamento
    if (boss.state === 'idle') {
        // Move lentamente para o centro
        let dx = (ROOM_W/2) - boss.x;
        boss.x += dx * 0.01;
    } else if (boss.state === 'charge') {
        let dx = player.x - boss.x, dy = player.y - boss.y;
        let dist = Math.hypot(dx, dy);
        boss.x += (dx/dist) * (boss.spd * 2.5);
        boss.y += (dy/dist) * (boss.spd * 2.5);
        // Cria rastro de dano
        if (boss.timer % 5 === 0) visuals.push({x: boss.x, y: boss.y, r: boss.r, life: 20, type: 'dust'});
    } else if (boss.state === 'shoot') {
        if (boss.timer % 15 === 0) {
            for(let i=0; i<8; i++) {
                let ang = (i / 8) * Math.PI * 2 + (boss.timer * 0.1);
                // Proj√©teis inimigos (simples, usam a mesma lista mas com flag isEnemy)
                projectiles.push({
                    x: boss.x, y: boss.y, vx: Math.cos(ang)*7, vy: Math.sin(ang)*7,
                    r: 15, dmg: 15, color: '#f0f', isEnemy: true, life: 200
                });
            }
        }
    } else if (boss.state === 'summon') {
        if (boss.timer === 50) {
            enemies.push({ x: boss.x + 100, y: boss.y, hp: 50, maxHp: 50, r: 20, spd: 4, behavior: 'chase' });
            enemies.push({ x: boss.x - 100, y: boss.y, hp: 50, maxHp: 50, r: 20, spd: 4, behavior: 'chase' });
        }
    }
}

// --- UPGRADES ---
function spawnUpgradeCrystal() {
    objects.push({ type: 'crystal', x: ROOM_W/2, y: ROOM_H/2, r: 40, angle: 0 });
}

function openUpgradeMenu() {
    G.play = false;
    const container = document.getElementById('upgrade-cards-area');
    container.innerHTML = '';
    
    let options = [];
    for(let i=0; i<3; i++) options.push(getWeightedUpgrade());

    options.forEach(upg => {
        const div = document.createElement('div');
        div.className = `upg-card ${upg.rarity}`;
        div.innerHTML = `
            <div class="upg-rarity">${upg.rarity}</div>
            <div style="flex:1; display:flex; align-items:center; justify-content:center; font-size:40px;">üîÆ</div>
            <div class="upg-name">${upg.name}</div>
            <div class="upg-desc">${upg.desc}</div>
        `;
        div.onclick = () => selectUpgrade(upg);
        container.appendChild(div);
    });

    document.getElementById('upgrade-screen').style.display = 'flex';
}

function getWeightedUpgrade() {
    const r = Math.random() * 100;
    let rarity = 'common';
    if (r > 60) rarity = 'rare';
    if (r > 90) rarity = 'epic';
    if (r > 98) rarity = 'legendary';

    let pool = UPGRADES_DB.filter(u => u.rarity === rarity);
    if(pool.length === 0) pool = UPGRADES_DB.filter(u => u.rarity === 'common');
    return pool[Math.floor(Math.random() * pool.length)];
}

function selectUpgrade(upg) {
    upg.apply(G.mods);
    document.getElementById('upgrade-screen').style.display = 'none';
    G.play = true;
    showPopup(texts.pt.upgrade);
    requestAnimationFrame(draw);
}

function swapWeapon() {
    if (G.unlockedWeapons.length <= 1) return;
    
    let currentIdx = G.unlockedWeapons.indexOf(G.curWpn);
    let nextIdx = (currentIdx + 1) % G.unlockedWeapons.length;
    G.curWpn = G.unlockedWeapons[nextIdx];

    const w = G.weapons[G.curWpn];
    document.getElementById('weapon-txt').innerText = w.name;
    document.getElementById('weapon-txt').style.color = w.color;
    
    // Feedback visual
    player.swapAnim = 10;
}

// --- INPUTS ---
function updateJoystickVisual(id, obj, joyId) {
    const base = document.getElementById(joyId);
    const stick = base.querySelector('.joystick-stick');
    
    if (obj.active) {
        base.style.display = 'block';
        base.style.left = obj.startX + 'px';
        base.style.top = obj.startY + 'px';
        
        let dx = obj.x, dy = obj.y;
        let dist = Math.hypot(dx, dy);
        let maxDist = 50;
        
        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }
        stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    } else {
        base.style.display = 'none';
    }
}

const setupTouch = (id, obj, joyId) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', e => { 
        e.preventDefault();
        obj.active = true;
        const t = e.changedTouches[0];
        obj.startX = t.clientX; obj.startY = t.clientY;
        obj.x = 0; obj.y = 0;
        updateJoystickVisual(id, obj, joyId);
    });
    el.addEventListener('touchmove', e => {
        e.preventDefault();
        for (let i=0; i<e.touches.length; i++) {
            const t = e.touches[i];
            let inZone = (id === 'left-zone' && t.clientX < window.innerWidth/2) || 
                         (id === 'right-zone' && t.clientX > window.innerWidth/2);
            if(inZone) {
                obj.x = t.clientX - obj.startX;
                obj.y = t.clientY - obj.startY;
                updateJoystickVisual(id, obj, joyId);
            }
        }
    });
    el.addEventListener('touchend', (e) => { 
        obj.active = false; obj.x = 0; obj.y = 0; 
        updateJoystickVisual(id, obj, joyId);
    });
};

setupTouch('left-zone', touchMove, 'joy-left');
setupTouch('right-zone', touchShoot, 'joy-right');

function update() {
    if(!G.play) return;

    if(keys['q'] || keys[' ']) {
        if(!keys.blockSwap) { swapWeapon(); keys.blockSwap = true; }
    } else { keys.blockSwap = false; }

    // Movimento Player
    let mx = 0, my = 0;
    if(keys['w']) my = -1; if(keys['s']) my = 1; if(keys['a']) mx = -1; if(keys['d']) mx = 1;
    if(touchMove.active) {
        let dist = Math.hypot(touchMove.x, touchMove.y);
        if(dist > 10) { mx = touchMove.x/dist; my = touchMove.y/dist; }
    }
    
    // Normalizar diagonal
    if(mx !== 0 || my !== 0) {
        player.x = Math.max(WALL_SIZE+25, Math.min(ROOM_W-WALL_SIZE-25, player.x + mx*player.spd));
        player.y = Math.max(WALL_SIZE+25, Math.min(ROOM_H-WALL_SIZE-25, player.y + my*player.spd));
    }

    // Ataque
    let ax = 0, ay = 0;
    if(keys['arrowup']) ay = -1; if(keys['arrowdown']) ay = 1; if(keys['arrowleft']) ax = -1; if(keys['arrowright']) ax = 1;
    if(touchShoot.active) {
        let dist = Math.hypot(touchShoot.x, touchShoot.y);
        if(dist > 20) { ax = touchShoot.x/dist; ay = touchShoot.y/dist; }
    }

    if(ax || ay) {
        player.angle = Math.atan2(ay, ax);
        const wpn = G.weapons[G.curWpn];
        
        // L√≥gica de Melee (Espada)
        if (wpn.type === 'melee') {
            if (Date.now() - G.lastShot > wpn.rate * (G.mods.fireRateMult * 0.8)) {
                // Cria √°rea de dano
                let swingSize = wpn.size * (G.mods.swordMaster ? 2 : 1.5);
                let swingDist = 60;
                
                // Visual
                visuals.push({ 
                    type: 'swing', x: player.x, y: player.y, angle: player.angle, 
                    life: 10, color: wpn.color, size: swingSize 
                });

                // Hitbox Melee
                let hitX = player.x + Math.cos(player.angle) * swingDist;
                let hitY = player.y + Math.sin(player.angle) * swingDist;

                enemies.forEach(en => {
                    if (Math.hypot(en.x - hitX, en.y - hitY) < swingSize + en.r) {
                        let dmg = wpn.dmg * G.mods.dmgMult;
                        if(Math.random() < G.mods.critChance) dmg *= 2;
                        en.hp -= dmg;
                        // Empurr√£o
                        en.x += Math.cos(player.angle) * 30;
                        en.y += Math.sin(player.angle) * 30;
                        
                        if(en.hp <= 0 && Math.random() < G.mods.lifesteal) G.hp = Math.min(G.maxHp, G.hp + 5);
                    }
                });
                
                // Refletir Proj√©teis (Espada Lend√°ria)
                if (G.mods.swordMaster) {
                    projectiles.forEach(p => {
                        if (p.isEnemy && Math.hypot(p.x - hitX, p.y - hitY) < swingSize + p.r) {
                            p.vx *= -2; p.vy *= -2; p.isEnemy = false; p.color = '#fff';
                        }
                    });
                }
                
                G.lastShot = Date.now();
            }
        } 
        // L√≥gica de Tiro (Range)
        else if (!G.reloading) {
            if(G.ammo > 0 || G.infiniteAmmo) {
                if(Date.now() - G.lastShot > wpn.rate * G.mods.fireRateMult) {
                    const baseDmg = wpn.dmg * G.mods.dmgMult;
                    const baseSize = wpn.size * G.mods.sizeMult;
                    const baseSpd = wpn.spd * G.mods.projSpdMult;

                    const shoot = (vx, vy) => {
                        projectiles.push({ 
                            x: player.x, y: player.y, vx: vx, vy: vy, 
                            r: baseSize, dmg: baseDmg, color: wpn.color,
                            pierce: G.mods.pierce, life: 100
                        });
                    };

                    shoot(ax*baseSpd, ay*baseSpd);
                    if(G.mods.multishot > 0) shoot((ax*0.9 - ay*0.2)*baseSpd, (ay*0.9 + ax*0.2)*baseSpd);
                    
                    if(!G.infiniteAmmo) G.ammo--;
                    G.lastShot = Date.now();
                }
            } else {
                G.reloading = true;
                setTimeout(() => { G.ammo = G.maxAmmo; G.reloading = false; }, G.reloadTime);
            }
        }
    }

    // Atualizar Inimigos (IA Melhorada)
    enemies.forEach((en, idx) => {
        if(en.isBoss) {
            updateBoss(en);
        } else {
            // IA Normal
            let dx = player.x - en.x;
            let dy = player.y - en.y;
            let dist = Math.hypot(dx, dy);
            
            // For√ßa de separa√ß√£o (Evitar empilhar)
            let sepX = 0, sepY = 0;
            enemies.forEach((other, oIdx) => {
                if(idx !== oIdx) {
                    let dX = en.x - other.x;
                    let dY = en.y - other.y;
                    let d = Math.hypot(dX, dY);
                    if(d < en.r * 2) {
                        sepX += dX / d;
                        sepY += dY / d;
                    }
                }
            });

            if (en.behavior === 'flank' && dist > 150) {
                 en.flankAngle += 0.02;
                 dx += Math.cos(en.flankAngle) * 100;
                 dy += Math.sin(en.flankAngle) * 100;
            }

            let angle = Math.atan2(dy, dx);
            en.x += Math.cos(angle) * en.spd + sepX;
            en.y += Math.sin(angle) * en.spd + sepY;
        }

        // Colis√£o com Player
        if(Math.hypot(player.x-en.x, player.y-en.y) < player.r + en.r) {
            let dmg = en.isBoss ? 1.5 : 0.8;
            if(G.mods.dmgRed > 0) dmg *= (1 - G.mods.dmgRed);
            G.hp -= dmg;
        }
    });

    // Atualizar Proj√©teis
    projectiles.forEach((p, pi) => {
        p.x += p.vx; p.y += p.vy;
        p.life--;
        if (p.life <= 0 || p.x < 0 || p.x > ROOM_W || p.y < 0 || p.y > ROOM_H) { projectiles.splice(pi, 1); return; }

        if (p.isEnemy) {
            // Tiro Inimigo acerta Player
            if (Math.hypot(p.x - player.x, p.y - player.y) < p.r + player.r) {
                G.hp -= 10 * (1 - G.mods.dmgRed);
                projectiles.splice(pi, 1);
            }
        } else {
            // Tiro Player acerta Inimigo
            for (let ei = enemies.length - 1; ei >= 0; ei--) {
                let en = enemies[ei];
                if(Math.hypot(p.x-en.x, p.y-en.y) < en.r + p.r) {
                    let finalDmg = p.dmg;
                    if(G.mods.instakill && !en.isBoss) finalDmg = en.hp + 999;
                    en.hp -= finalDmg;

                    // Efeito de Morte
                    if(en.hp <= 0) {
                        if(G.mods.explode) {
                             // Dano em √°rea simples
                             enemies.forEach(nearby => {
                                 if(Math.hypot(nearby.x - en.x, nearby.y - en.y) < 150) nearby.hp -= 50;
                             });
                             visuals.push({type: 'explosion', x: en.x, y: en.y, life: 10});
                        }
                        
                        // Drops
                        let dropR = Math.random();
                        if (dropR < 0.3) drops.push({x: en.x, y: en.y, type: 'hp'});
                        else if (dropR < 0.5) drops.push({x: en.x, y: en.y, type: 'ammo'});

                        enemies.splice(ei, 1);
                    }

                    if(p.pierce > 0) p.pierce--;
                    else { projectiles.splice(pi, 1); break; }
                }
            }
        }
    });

    // Pickups
    drops.forEach((d, i) => { 
        if(Math.hypot(player.x-d.x, player.y-d.y) < 50) { 
            if (d.type === 'hp') G.hp = Math.min(G.maxHp, G.hp+25);
            if (d.type === 'ammo') G.ammo = Math.min(G.maxAmmo, G.ammo+10);
            drops.splice(i, 1); 
        } 
    });

    // Objetos
    objects.forEach((o, i) => {
        if(o.type === 'crystal') o.angle += 0.05;
        if(Math.hypot(player.x-o.x, player.y-o.y) < o.r + player.r) {
            if(o.type === 'weapon') {
                if (!G.unlockedWeapons.includes(o.wpnIdx)) {
                    G.unlockedWeapons.push(o.wpnIdx);
                    showPopup(o.wpnIdx === 2 ? texts.pt.sword : texts.pt.weapon);
                    // Troca autom√°tica
                    G.curWpn = o.wpnIdx;
                }
                objects.splice(i, 1); 
                document.getElementById('mobile-swap-btn').style.display = 'flex';
            }
            if(o.type === 'crystal') {
                objects.splice(i, 1);
                openUpgradeMenu();
            }
        }
    });

    // Visuals update
    visuals.forEach((v, i) => {
        v.life--;
        if(v.life <= 0) visuals.splice(i, 1);
    });

    // Check Fim da Sala
    if(enemies.length === 0 && !G.enemiesDefeated) {
        G.enemiesDefeated = true;
        G.clearedRooms.add(G.room);
        if(G.room > 0 && G.room % 10 === 0) spawnUpgradeCrystal();
        
        // Drop de Armas Espec√≠ficas
        // Andar 5: Arma de Fogo
        if (G.room === 5 && !G.unlockedWeapons.includes(1)) {
             objects.push({ type: 'weapon', x: ROOM_W/2, y: ROOM_H/2, r: 40, wpnIdx: 1 });
        }
        // Andar 8 ou 3: Espada do Rei
        if (G.room === 3 && !G.unlockedWeapons.includes(2)) {
             objects.push({ type: 'weapon', x: ROOM_W/2, y: ROOM_H/2, r: 40, wpnIdx: 2 });
        }
        
        // Garante persist√™ncia
        saveRoomState();
    }

    // Portas
    if (G.enemiesDefeated && objects.filter(o => o.type === 'crystal').length === 0) { 
        const doorW = 200;
        if (player.y < WALL_SIZE + 30 && player.x > ROOM_W/2 - doorW/2 && player.x < ROOM_W/2 + doorW/2) {
            G.room++; initRoom('bottom');
        }
        if (G.room > 0 && player.y > ROOM_H - WALL_SIZE - 30 && player.x > ROOM_W/2 - doorW/2 && player.x < ROOM_W/2 + doorW/2) {
            G.room--; initRoom('top');
        }
    }

    if(G.hp <= 0) {
        alert("GAME OVER - Voc√™ sucumbiu √†s sombras.");
        location.reload();
    }
}

function drawMinimap() {
    mCtx.clearRect(0,0,mCanvas.width, mCanvas.height);
    const sw = mCanvas.width / ROOM_W;
    const sh = mCanvas.height / ROOM_H;

    mCtx.fillStyle = "#fff"; mCtx.fillRect(player.x * sw, player.y * sh, 4, 4);
    mCtx.fillStyle = "#f00"; enemies.forEach(en => mCtx.fillRect(en.x * sw, en.y * sh, 3, 3));
    
    objects.forEach(o => {
        mCtx.fillStyle = o.type === 'crystal' ? '#0ff' : '#f1c40f';
        mCtx.fillRect(o.x * sw, o.y * sh, 5, 5);
    });

    if(G.enemiesDefeated && objects.filter(o=>o.type==='crystal').length === 0) {
        mCtx.strokeStyle = "#f00";
        mCtx.strokeRect((ROOM_W/2-50)*sw, 0, 100*sw, 10*sh);
        if(G.room > 0) mCtx.strokeRect((ROOM_W/2-50)*sw, mCanvas.height - 10*sh, 100*sw, 10*sh);
    }
}

function draw() {
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width, canvas.height);
    
    // Se o menu de upgrade estiver aberto, n√£o atualiza l√≥gica, apenas desenha (pausa)
    if(document.getElementById('upgrade-screen').style.display !== 'flex') {
        update();
    }
    
    drawMinimap();

    ctx.save();
    // Camera
    let zoom = Math.min(canvas.width/ROOM_W, canvas.height/ROOM_H);
    // Para salas grandes (Boss), limitar zoom out
    if(ROOM_W > 1600) zoom = Math.max(zoom, 0.4); 

    let camX = canvas.width/2 - player.x*zoom;
    let camY = canvas.height/2 - player.y*zoom;
    
    // Clamp camera
    camX = Math.min(0, Math.max(canvas.width - ROOM_W*zoom, camX));
    camY = Math.min(0, Math.max(canvas.height - ROOM_H*zoom, camY));

    ctx.translate(camX, camY);
    ctx.scale(zoom, zoom);

    // Ch√£o
    ctx.fillStyle = "#0d0000"; ctx.fillRect(0,0,ROOM_W,ROOM_H);
    // Paredes
    ctx.fillStyle = "#1a0000"; 
    ctx.fillRect(0,0,ROOM_W,WALL_SIZE); ctx.fillRect(0,ROOM_H-WALL_SIZE,ROOM_W,WALL_SIZE);
    ctx.fillRect(0,0,WALL_SIZE,ROOM_H); ctx.fillRect(ROOM_W-WALL_SIZE,0,WALL_SIZE,ROOM_H);
    
    // Grid sutil
    ctx.strokeStyle = "#200000"; ctx.lineWidth = 2;
    ctx.beginPath();
    for(let x=0; x<ROOM_W; x+=100) { ctx.moveTo(x,0); ctx.lineTo(x,ROOM_H); }
    for(let y=0; y<ROOM_H; y+=100) { ctx.moveTo(0,y); ctx.lineTo(ROOM_W,y); }
    ctx.stroke();

    // Portas
    if(G.enemiesDefeated && objects.filter(o=>o.type==='crystal').length === 0) {
        ctx.fillStyle = "#ff0000"; ctx.shadowBlur = 30; ctx.shadowColor = "#f00";
        ctx.fillRect(ROOM_W/2-100, 0, 200, WALL_SIZE + 15);
        if (G.room > 0) ctx.fillRect(ROOM_W/2-100, ROOM_H - WALL_SIZE - 15, 200, WALL_SIZE + 15);
        ctx.shadowBlur = 0;
    }

    // Objetos
    objects.forEach(o => {
        if(o.type === 'weapon') {
            ctx.fillStyle = "#333"; ctx.fillRect(o.x-40, o.y-40, 80, 80);
            ctx.font = "40px Arial"; ctx.textAlign = "center";
            if (o.wpnIdx === 1) ctx.fillText("üî´", o.x, o.y+15);
            else if (o.wpnIdx === 2) ctx.fillText("‚öîÔ∏è", o.x, o.y+15);
            else ctx.fillText("?", o.x, o.y+15);
        }
        if(o.type === 'crystal') {
            ctx.save();
            ctx.translate(o.x, o.y); ctx.rotate(o.angle);
            ctx.fillStyle = "#00ffff"; ctx.shadowColor = "#00ffff"; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.moveTo(0, -30); ctx.lineTo(20, 0); ctx.lineTo(0, 30); ctx.lineTo(-20, 0); ctx.fill();
            ctx.restore();
        }
    });

    drops.forEach(d => { 
        ctx.font = "30px Orbitron"; ctx.textAlign = "center";
        if (d.type === 'hp') { ctx.fillStyle = "#f00"; ctx.fillText("‚ô•", d.x, d.y+10); }
        if (d.type === 'ammo') { ctx.fillStyle = "#ff0"; ctx.fillText("‚ñÆ", d.x, d.y+10); }
    });

    // Inimigos
    enemies.forEach(en => {
        ctx.save();
        ctx.translate(en.x, en.y);
        ctx.fillStyle = en.isBoss ? "#600" : "#f00";
        ctx.beginPath(); ctx.arc(0, 0, en.r, 0, Math.PI*2); ctx.fill();
        
        // Olhos
        ctx.fillStyle = "#000";
        ctx.beginPath(); ctx.arc(-en.r/3, -en.r/4, en.r/4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(en.r/3, -en.r/4, en.r/4, 0, Math.PI*2); ctx.fill();
        
        ctx.restore();
        
        // Barra HP Inimigo
        let hpPct = en.hp / en.maxHp;
        ctx.fillStyle = "#222"; ctx.fillRect(en.x-40, en.y-en.r-20, 80, 8);
        ctx.fillStyle = "#f00"; ctx.fillRect(en.x-40, en.y-en.r-20, 80 * hpPct, 8);
    });

    // Player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle + Math.PI/2); // Rotacionar para olhar para o alvo
    
    ctx.fillStyle = G.reloading ? "#444" : "#fff";
    ctx.beginPath(); ctx.arc(0, 0, player.r, 0, Math.PI*2); ctx.fill();
    // Indicador da arma atual (Corpo)
    ctx.strokeStyle = G.weapons[G.curWpn].color; ctx.lineWidth = 5; ctx.stroke();
    
    // Desenho Arma
    if (G.weapons[G.curWpn].type === 'range') {
        ctx.fillStyle = G.weapons[G.curWpn].color;
        ctx.fillRect(-5, -35, 10, 20); // Cano da arma
    } else {
        // Espada Visual no player (Idle)
        ctx.strokeStyle = "#9932CC"; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(10, -40); ctx.stroke();
    }
    ctx.restore();

    // Proj√©teis
    projectiles.forEach(p => { 
        ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill(); 
    });

    // Efeitos Visuais (Swings de espada, explos√µes)
    visuals.forEach(v => {
        if (v.type === 'swing') {
            ctx.save();
            ctx.translate(v.x, v.y);
            ctx.rotate(v.angle);
            ctx.strokeStyle = v.color;
            ctx.lineWidth = 5;
            ctx.globalAlpha = v.life / 10;
            ctx.beginPath();
            ctx.arc(0, 0, v.size, -Math.PI/3, Math.PI/3);
            ctx.stroke();
            ctx.restore();
        }
        if (v.type === 'explosion' || v.type === 'dust') {
             ctx.fillStyle = v.type === 'dust' ? '#555' : '#fa0';
             ctx.globalAlpha = v.life / 10;
             ctx.beginPath(); ctx.arc(v.x, v.y, v.type==='dust'? 40 : 100, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
    });

    ctx.restore();
    
    // Update HUD
    document.getElementById('hp-bar').style.width = Math.max(0, (G.hp/G.maxHp*100)) + "%";
    document.getElementById('ammo-bar').style.width = G.infiniteAmmo || G.weapons[G.curWpn].type==='melee' ? "100%" : (G.ammo/G.maxAmmo*100) + "%";
    document.getElementById('room-txt').innerText = G.room;
    
    requestAnimationFrame(draw);
}

window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => delete keys[e.key.toLowerCase()]);
window.onresize = () => { 
    canvas.width = window.innerWidth; canvas.height = window.innerHeight; 
    mCanvas.width = 120; mCanvas.height = 80;
};
window.onresize(); draw();
</script>
</body>
</html>
