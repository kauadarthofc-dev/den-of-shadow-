<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Den of Shadow ðŸ’€ V3.0 Reforged</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Nosifer&display=swap');
        
        :root { --c-red: #ff0000; --c-dark: #110000; --c-glass: rgba(20, 0, 0, 0.9); }
        * { touch-action: none; user-select: none; box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body { margin: 0; background: #000; color: white; font-family: 'Orbitron', sans-serif; overflow: hidden; width: 100vw; height: 100vh; }
        
        /* CANVAS & LAYERS */
        #game-layer { position: relative; width: 100%; height: 100%; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        
        /* UI SCREENS */
        .ui-screen { position: absolute; inset: 0; background: rgba(0,0,0,0.92); z-index: 50; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; transition: opacity 0.3s; }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }
        
        .panel { background: var(--c-dark); border: 2px solid var(--c-red); padding: 25px; width: 90%; max-width: 500px; border-radius: 4px; box-shadow: 0 0 30px rgba(255,0,0,0.2); position: relative; }
        
        h1 { font-family: 'Nosifer', cursive; color: var(--c-red); margin: 0 0 10px 0; font-size: 2rem; text-shadow: 0 0 10px var(--c-red); }
        h2 { font-size: 1.2rem; margin-bottom: 20px; color: #fff; }
        
        /* BUTTONS */
        .btn-grid { display: grid; gap: 10px; margin-top: 20px; }
        .btn { background: #300; border: 1px solid var(--c-red); color: white; padding: 15px; font-family: inherit; font-size: 1rem; cursor: pointer; transition: all 0.2s; text-transform: uppercase; position: relative; }
        .btn:hover, .btn:active { background: #600; box-shadow: 0 0 15px var(--c-red); }
        .btn small { display: block; font-size: 0.7em; color: #aaa; margin-top: 4px; }
        .btn-del { position: absolute; right: 5px; top: 5px; background: red; color: black; border: none; width: 24px; height: 24px; font-weight: bold; cursor: pointer; z-index: 10; }
        
        /* HUD */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 40; display: none; }
        .hud-top { position: absolute; top: 15px; left: 15px; display: flex; flex-direction: column; gap: 8px; }
        .health-bar { display: flex; gap: 4px; }
        .hp-icon { width: 18px; height: 24px; background: var(--c-red); clip-path: polygon(50% 0, 100% 25%, 100% 75%, 50% 100%, 0 75%, 0 25%); transition: 0.2s; }
        .hp-icon.lost { background: #333; opacity: 0.5; transform: scale(0.9); }
        .stats { font-size: 14px; text-shadow: 1px 1px 0 #000; color: #f55; font-weight: bold; letter-spacing: 1px; }
        
        /* CROSSHAIR */
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 4px; height: 4px; background: var(--c-red); border-radius: 50%; box-shadow: 0 0 4px var(--c-red); z-index: 35; }

        /* DAMAGE FLASH */
        #flash { position: absolute; inset: 0; background: red; opacity: 0; pointer-events: none; z-index: 45; transition: opacity 0.1s; }

        /* MOBILE CONTROLS */
        #mobile-layer { position: absolute; inset: 0; z-index: 60; display: none; }
        .touch-zone { position: absolute; }
        #zone-move { bottom: 20px; left: 20px; width: 160px; height: 160px; }
        #zone-look { top: 0; left: 0; width: 100%; height: 100%; z-index: -1; } /* Background layer */
        
        /* Joystick Visual */
        #joy-base { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; border: 2px solid rgba(255,0,0,0.3); border-radius: 50%; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
        #joy-stick { position: absolute; top: 30px; left: 30px; width: 40px; height: 40px; background: rgba(255,0,0,0.5); border-radius: 50%; }
        #joy-base.active { opacity: 1; }

        /* Action Buttons */
        .actions { position: absolute; bottom: 30px; right: 30px; display: flex; flex-direction: column; gap: 20px; pointer-events: auto; }
        .btn-round { width: 70px; height: 70px; border-radius: 50%; background: rgba(50,0,0,0.6); border: 2px solid var(--c-red); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; transition: 0.1s; backdrop-filter: blur(2px); }
        .btn-round:active, .btn-round.pressed { background: var(--c-red); color: black; transform: scale(0.95); }
        #btn-jump { width: 50px; height: 50px; align-self: flex-end; margin-right: 10px; border-color: #aaa; }
        #btn-use { border-color: #0f0; color: #afa; }

        /* Responsive Grid for Saves */
        .save-grid { display: grid; grid-template-columns: 1fr; gap: 10px; max-height: 300px; overflow-y: auto; }
        @media (min-width: 600px) { .save-grid { grid-template-columns: repeat(3, 1fr); } }
    </style>
</head>
<body>

<div id="screen-menu" class="ui-screen">
    <div class="panel">
        <h1>DEN OF SHADOW</h1>
        <p style="color:#f66; font-size:12px; margin-top:-10px;">REFORGED V3.0</p>
        
        <div id="menu-slots">
            <h2>SELECIONE O SLOT</h2>
            <div class="save-grid">
                </div>
        </div>

        <div id="menu-classes" class="hidden">
            <h2>ESCOLHA A CLASSE</h2>
            <div class="btn-grid">
                <button class="btn" onclick="Game.startNewGame('assassin')">ASSASSINO<small>RÃ¡pido / Faca</small></button>
                <button class="btn" onclick="Game.startNewGame('soldier')">SOLDADO<small>Resistente / Pistola</small></button>
                <button class="btn" onclick="Game.startNewGame('mage')">MAGO<small>Poderoso / Magia</small></button>
                <button class="btn" style="background:#111" onclick="UI.showSlots()">Voltar</button>
            </div>
        </div>
    </div>
</div>

<div id="screen-gameover" class="ui-screen hidden">
    <div class="panel">
        <h1 style="font-size: 3rem;">MORREU</h1>
        <p id="death-stats">Almas Coletadas: 0</p>
        <div class="btn-grid">
            <button class="btn" onclick="Game.retry()">TENTAR NOVAMENTE</button>
            <button class="btn" style="background:#111" onclick="Game.toMenu()">MENU PRINCIPAL</button>
        </div>
    </div>
</div>

<div id="hud">
    <div class="hud-top">
        <div class="health-bar" id="hud-hp"></div>
        <div class="stats">SALA: <span id="hud-room">1</span> | ALMAS: <span id="hud-souls">0</span></div>
    </div>
    <div id="crosshair"></div>
    <div id="flash"></div>
</div>

<div id="game-layer">
    <canvas id="canvas"></canvas>
    
    <div id="mobile-layer">
        <div id="zone-look" class="touch-zone"></div>
        <div id="zone-move" class="touch-zone">
            <div id="joy-base"><div id="joy-stick"></div></div>
        </div>
        <div class="actions">
            <div class="btn-round" id="btn-fire">ATACAR</div>
            <div class="btn-round" id="btn-use">USAR</div>
            <div class="btn-round" id="btn-jump">PULAR</div>
        </div>
    </div>
</div>

<script>
/**
 * â”€â”€â”€â”€ CONSTANTS & CONFIG â”€â”€â”€â”€
 */
const C = {
    TILE_SIZE: 64,
    MAP_SIZE: 24,
    FOV: Math.PI / 3,
    RES_DIVIDER: 4, // 1 = High Quality, 4 = Retro/Fast
    MAX_DIST: 800,
    GRAVITY: 0.8,
    COLORS: {
        floor: '#150505',
        ceil: '#050000',
        wall: [150, 0, 0], // RGB Base
        door: [0, 200, 0]
    }
};

/**
 * â”€â”€â”€â”€ UTILS â”€â”€â”€â”€
 */
const M = {
    toRad: (d) => d * Math.PI / 180,
    dist: (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2),
    clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
    normalizeAngle: (a) => {
        a = a % (2 * Math.PI);
        if (a < 0) a += (2 * Math.PI);
        return a;
    }
};

/**
 * â”€â”€â”€â”€ SOUND MANAGER (Web Audio API) â”€â”€â”€â”€
 */
class SoundManager {
    constructor() {
        this.ctx = null;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    playTone(freq, type, duration, vol=0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    shoot(type) {
        if(type === 'knife') this.playTone(600, 'triangle', 0.1, 0.05); // Swoosh
        else if(type === 'pistol') this.playTone(150, 'sawtooth', 0.3, 0.2); // Bang
        else this.playTone(800, 'sine', 0.4, 0.1); // Magic
    }

    hit() { this.playTone(100, 'square', 0.2, 0.2); }
    step() { this.playTone(50, 'triangle', 0.05, 0.05); }
    door() { this.playTone(80, 'sine', 0.5, 0.1); }
}

/**
 * â”€â”€â”€â”€ INPUT MANAGER â”€â”€â”€â”€
 */
class InputManager {
    constructor() {
        this.keys = {};
        this.pLock = false;
        this.actions = { fire: false, use: false, jump: false };
        
        // Mobile Virtual Joystick
        this.joy = { active: false, dx: 0, dy: 0, originX: 0, originY: 0, id: null };
        this.look = { active: false, x: 0, y: 0, id: null };
        
        this.setupListeners();
    }

    setupListeners() {
        // Keyboard
        window.addEventListener('keydown', e => {
            this.keys[e.code] = true;
            if(e.code === 'KeyE') this.actions.use = true;
            if(e.code === 'Space') this.actions.jump = true;
        });
        window.addEventListener('keyup', e => {
            this.keys[e.code] = false;
            if(e.code === 'KeyE') this.actions.use = false;
            if(e.code === 'Space') this.actions.jump = false;
        });

        // Mouse (Pointer Lock)
        document.addEventListener('mousedown', () => {
            if(Game.state !== 'PLAYING') return;
            if(!this.pLock && !Game.isMobile) {
                document.getElementById('canvas').requestPointerLock();
            } else {
                this.actions.fire = true;
            }
        });
        document.addEventListener('mouseup', () => this.actions.fire = false);
        document.addEventListener('mousemove', e => {
            if(this.pLock) {
                Game.player.angle += e.movementX * 0.002;
                Game.player.pitch = M.clamp(Game.player.pitch - e.movementY * 2, -200, 200);
            }
        });
        document.addEventListener('pointerlockchange', () => {
            this.pLock = !!document.pointerLockElement;
        });

        // Mobile Touch
        const mLayer = document.getElementById('mobile-layer');
        const zMove = document.getElementById('zone-move');
        const zLook = document.getElementById('zone-look');
        const stick = document.getElementById('joy-stick');
        const base = document.getElementById('joy-base');

        // Joystick Logic
        zMove.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            this.joy.id = t.identifier;
            this.joy.active = true;
            this.joy.originX = t.clientX;
            this.joy.originY = t.clientY;
            
            // Visual feedback
            base.style.left = t.clientX + 'px';
            base.style.top = t.clientY + 'px';
            base.classList.add('active');
            stick.style.transform = `translate(0px, 0px)`;
        }, {passive: false});

        zMove.addEventListener('touchmove', e => {
            e.preventDefault();
            if(!this.joy.active) return;
            for(let i=0; i<e.changedTouches.length; i++){
                const t = e.changedTouches[i];
                if(t.identifier === this.joy.id) {
                    let dx = t.clientX - this.joy.originX;
                    let dy = t.clientY - this.joy.originY;
                    let dist = Math.min(50, Math.hypot(dx, dy));
                    let angle = Math.atan2(dy, dx);
                    
                    this.joy.dx = (Math.cos(angle) * dist) / 50;
                    this.joy.dy = (Math.sin(angle) * dist) / 50;
                    
                    stick.style.transform = `translate(${this.joy.dx * 25}px, ${this.joy.dy * 25}px)`;
                }
            }
        }, {passive: false});

        const endJoy = (e) => {
             for(let i=0; i<e.changedTouches.length; i++){
                if(e.changedTouches[i].identifier === this.joy.id) {
                    this.joy.active = false;
                    this.joy.dx = 0; this.joy.dy = 0;
                    base.classList.remove('active');
                }
             }
        };
        zMove.addEventListener('touchend', endJoy);
        zMove.addEventListener('touchcancel', endJoy);

        // Look Logic
        zLook.addEventListener('touchstart', e => {
            const t = e.changedTouches[0];
            this.look.id = t.identifier;
            this.look.x = t.clientX;
            this.look.y = t.clientY;
        }, {passive: true});

        zLook.addEventListener('touchmove', e => {
            for(let i=0; i<e.changedTouches.length; i++){
                const t = e.changedTouches[i];
                if(t.identifier === this.look.id) {
                    let dx = t.clientX - this.look.x;
                    let dy = t.clientY - this.look.y;
                    Game.player.angle += dx * 0.005; // Sensibilidade Horizontal
                    Game.player.pitch = M.clamp(Game.player.pitch - dy * 2, -200, 200); // Sensibilidade Vertical
                    this.look.x = t.clientX;
                    this.look.y = t.clientY;
                }
            }
        }, {passive: false});

        // Touch Buttons
        const bindBtn = (id, action) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); this.actions[action] = true; el.classList.add('pressed'); });
            el.addEventListener('touchend', (e) => { e.preventDefault(); this.actions[action] = false; el.classList.remove('pressed'); });
        };
        bindBtn('btn-fire', 'fire');
        bindBtn('btn-use', 'use');
        bindBtn('btn-jump', 'jump');
    }

    getMovementVector() {
        let dx = 0, dy = 0;
        // Keyboard
        if(this.keys['KeyW']) dx = 1;
        if(this.keys['KeyS']) dx = -1;
        if(this.keys['KeyA']) dy = -1; // Strafe left
        if(this.keys['KeyD']) dy = 1;  // Strafe right
        
        // Joystick override
        if(this.joy.active) {
            dx = -this.joy.dy; // Joy Y is inverted relative to forward
            dy = this.joy.dx;
        }
        return { forward: dx, strafe: dy };
    }
}

/**
 * â”€â”€â”€â”€ RENDERER (Raycaster) â”€â”€â”€â”€
 */
class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false });
        this.zBuffer = [];
        this.resize();
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width / C.RES_DIVIDER;
        this.canvas.height = this.height / C.RES_DIVIDER;
        this.ctx.imageRendering = 'pixelated';
        this.zBuffer = new Array(this.canvas.width).fill(0);
    }

    draw(player, map, entities) {
        // Clear & Draw Floor/Ceiling
        const w = this.canvas.width;
        const h = this.canvas.height;
        const horizon = h / 2 + player.pitch;

        // Simple gradient fill for better performance than per-pixel raycasting for floor
        this.ctx.fillStyle = C.COLORS.ceil;
        this.ctx.fillRect(0, 0, w, horizon);
        this.ctx.fillStyle = C.COLORS.floor;
        this.ctx.fillRect(0, horizon, w, h - horizon);

        // Raycasting (DDA Algorithm)
        for (let x = 0; x < w; x++) {
            const cameraX = 2 * x / w - 1;
            const rayDirX = Math.cos(player.angle) + Math.cos(player.angle + Math.PI/2) * cameraX * (C.FOV/2);
            const rayDirY = Math.sin(player.angle) + Math.sin(player.angle + Math.PI/2) * cameraX * (C.FOV/2);

            let mapX = Math.floor(player.x / C.TILE_SIZE);
            let mapY = Math.floor(player.y / C.TILE_SIZE);
            
            let sideDistX, sideDistY;
            const deltaDistX = Math.abs(1 / rayDirX);
            const deltaDistY = Math.abs(1 / rayDirY);
            let perpWallDist;
            let stepX, stepY;
            let hit = 0, side = 0;

            if (rayDirX < 0) { stepX = -1; sideDistX = (player.x / C.TILE_SIZE - mapX) * deltaDistX; }
            else { stepX = 1; sideDistX = (mapX + 1.0 - player.x / C.TILE_SIZE) * deltaDistX; }
            
            if (rayDirY < 0) { stepY = -1; sideDistY = (player.y / C.TILE_SIZE - mapY) * deltaDistY; }
            else { stepY = 1; sideDistY = (mapY + 1.0 - player.y / C.TILE_SIZE) * deltaDistY; }

            // DDA Loop
            let maxSteps = 40; 
            while (hit === 0 && maxSteps > 0) {
                if (sideDistX < sideDistY) {
                    sideDistX += deltaDistX; mapX += stepX; side = 0;
                } else {
                    sideDistY += deltaDistY; mapY += stepY; side = 1;
                }
                if (mapX < 0 || mapX >= C.MAP_SIZE || mapY < 0 || mapY >= C.MAP_SIZE) { hit = 1; }
                else if (map[mapY * C.MAP_SIZE + mapX] > 0) { hit = map[mapY * C.MAP_SIZE + mapX]; }
                maxSteps--;
            }

            if (side === 0) perpWallDist = (sideDistX - deltaDistX);
            else perpWallDist = (sideDistY - deltaDistY);

            this.zBuffer[x] = perpWallDist * C.TILE_SIZE; // Save for sprite depth check

            // Draw Wall Strip
            const lineHeight = Math.floor(h / perpWallDist);
            const drawStart = Math.floor(-lineHeight / 2 + horizon + player.z);
            
            // Wall Colors & Simple Shading
            let color = hit === 2 ? C.COLORS.door : C.COLORS.wall;
            // Darker if side wall (pseudo lighting)
            let r = color[0], g = color[1], b = color[2];
            if(side === 1) { r*=0.7; g*=0.7; b*=0.7; }
            // Distance fog
            const fog = Math.min(1, 4 / perpWallDist);
            r *= fog; g *= fog; b *= fog;

            this.ctx.fillStyle = `rgb(${r},${g},${b})`;
            this.ctx.fillRect(x, drawStart, 1, lineHeight);
        }

        // Draw Entities (Sprites)
        this.drawSprites(player, entities, w, h, horizon);
        
        // Draw Weapon
        this.drawWeapon(player, w, h);
    }

    drawSprites(player, entities, w, h, horizon) {
        // Sort entities by distance to player
        entities.forEach(e => {
            e.dist = Math.hypot(player.x - e.x, player.y - e.y);
        });
        entities.sort((a, b) => b.dist - a.dist);

        entities.forEach(e => {
            if(!e.alive) return;
            
            // Transform sprite with the inverse camera matrix
            const spriteX = e.x - player.x;
            const spriteY = e.y - player.y;

            // Simple vector projection
            const invDet = 1.0 / (Math.cos(player.angle) * Math.sin(player.angle + Math.PI/2) - Math.cos(player.angle + Math.PI/2) * Math.sin(player.angle));
            const transformX = invDet * (Math.sin(player.angle + Math.PI/2) * spriteX - Math.cos(player.angle + Math.PI/2) * spriteY);
            const transformY = invDet * (-Math.sin(player.angle) * spriteX + Math.cos(player.angle) * spriteY); // Depth inside screen

            if (transformY <= 0) return; // Behind player

            const spriteScreenX = Math.floor((w / 2) * (1 + transformX / transformY));
            const spriteHeight = Math.abs(Math.floor(h / (transformY / C.TILE_SIZE))); 
            const spriteTop = Math.floor(-spriteHeight / 2 + horizon + player.z);
            
            if (spriteHeight > 2000) return; // Too close/clipping

            // Render primitive "sprite" (Circle or Square)
            const size = spriteHeight / 1.5;
            const xStart = Math.floor(spriteScreenX - size / 2);
            
            // Check Z-Buffer for center pixel to decide visibility
            if(xStart > 0 && xStart < w && transformY * C.TILE_SIZE < this.zBuffer[Math.floor(spriteScreenX)]) {
                if(e.type === 'bullet') {
                    this.ctx.fillStyle = '#ff0';
                    this.ctx.beginPath();
                    this.ctx.arc(spriteScreenX, spriteTop + spriteHeight/2, size/4, 0, Math.PI*2);
                    this.ctx.fill();
                } else {
                    // Enemy
                    this.ctx.fillStyle = e.type === 'BOSS' ? '#f0f' : '#f00';
                    if(e.hitTime > 0) this.ctx.fillStyle = '#fff'; // Flash white on hit
                    this.ctx.fillRect(xStart, spriteTop, size, spriteHeight);
                    
                    // Eyes
                    this.ctx.fillStyle = '#ff0';
                    this.ctx.fillRect(xStart + size*0.2, spriteTop + size*0.2, size*0.2, size*0.2);
                    this.ctx.fillRect(xStart + size*0.6, spriteTop + size*0.2, size*0.2, size*0.2);
                }
            }
        });
    }

    drawWeapon(player, w, h) {
        const bob = Math.sin(Date.now() / 150) * (player.isMoving ? 10 : 2);
        const recoil = player.recoil * 5;
        const wx = w * 0.6;
        const wy = h - (h * 0.3) + bob + recoil;

        this.ctx.save();
        if(player.weapon === 'knife') {
            this.ctx.translate(wx, wy);
            this.ctx.rotate(-player.recoil * 0.2);
            this.ctx.fillStyle = '#888';
            this.ctx.fillRect(0, 0, 40, 150); // LÃ¢mina
            this.ctx.fillStyle = '#300';
            this.ctx.fillRect(5, 100, 30, 60); // Cabo
        } else {
            // Gun / Magic
            this.ctx.fillStyle = player.weapon === 'magic' ? '#508' : '#333';
            this.ctx.fillRect(wx - 20, wy, 40, 120);
            // Muzzle flash
            if(player.recoil > 5) {
                this.ctx.fillStyle = player.weapon === 'magic' ? '#f0f' : '#fa0';
                this.ctx.beginPath();
                this.ctx.arc(wx, wy - 20, 30 + Math.random()*10, 0, Math.PI*2);
                this.ctx.fill();
            }
        }
        this.ctx.restore();
    }
}

/**
 * â”€â”€â”€â”€ ENTITIES â”€â”€â”€â”€
 */
class Entity {
    constructor(x, y) {
        this.x = x; this.y = y; this.alive = true;
    }
}

class Enemy extends Entity {
    constructor(x, y, type, roomLevel) {
        super(x, y);
        this.type = type; // 'MOB' or 'BOSS'
        this.hp = type === 'BOSS
